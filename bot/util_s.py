from arrow import utcnow, get
from typing import List, Tuple
from pprint import pprint
import io
from pprint import pprint


import io


# import psutil  # Для мониторинга загрузки процессора
from pprint import pprint

import logging

logger = logging.getLogger(__name__)


def format_message_list2(obj):
    text = ""  # Создаем пустую строку, в которую будем добавлять текст
    messages = []  # Создаем пустой список для хранения сообщений

    if len(obj) > 0:  # Проверяем, что входной объект не пуст
        logger.debug("Processing non-empty object")
        for k, v in obj.items():  # Проходим по ключам и значениям в объекте
            key = str(k)  # Преобразуем ключ в строку
            val = str(v)  # Преобразуем значение в строку
            total_len = len(key) + len(val)  # Вычисляем общую длину ключа и значения
            pad = 31 - total_len % 31  # Вычисляем количество пробелов для выравнивания

            text += key  # Добавляем ключ в текст

            if pad > 0:
                text += " " * pad  # Добавляем пробелы для выравнивания

            if total_len > 31:
                text += " " * 2  # Добавляем двойные пробелы, если общая длина больше 31

            text += str(v)  # Добавляем значение в текст
            text += "\n"  # Добавляем символ новой строки

        # Разбиваем текст на части, если он слишком большой
        index = 0
        size = 4000
        while len(text) > 0:
            part = text[index : index + size]  # Вырезаем часть текста заданного размера
            index = part.rfind("\n")  # Находим последний символ новой строки в части
            if index == -1:
                index = len(
                    text
                )  # Если символ новой строки не найден, используем конец текста
            part = text[0:index]  # Выбираем часть текста до символа новой строки
            messages.append(
                "```\n" + part + "\n```"
            )  # Добавляем часть текста в список сообщений
            text = text[
                index:
            ].strip()  # Удаляем обработанную часть из текста и убираем пробелы

        logger.debug("Finished formatting messages")
    else:
        logger.debug("Input object is empty")

    return messages  # Возвращаем список сообщений


def format_message_list4(obj):
    text = ""  # Создаем пустую строку для хранения текста сообщений.
    messages = []  # Создаем пустой список для хранения отформатированных сообщений.

    if len(obj) > 0:  # Проверяем, есть ли объекты в списке.
        logger.debug("Processing non-empty object")
        for i in obj:  # Проходим по каждому объекту в списке.
            for k, v in i.items():  # Проходим по каждой паре ключ-значение в объекте.
                key = str(k)  # Преобразуем ключ в строку.
                val = str(v)  # Преобразуем значение в строку.
                total_len = len(key) + len(
                    val
                )  # Вычисляем общую длину ключа и значения.
                pad = (
                    30 - total_len % 30
                )  # Вычисляем количество пробелов, чтобы выровнять текст.

                text += key  # Добавляем ключ к тексту.

                if pad > 0:  # Если нужно добавить пробелы для выравнивания,
                    text += " " * pad  # добавляем их.

                if total_len > 30:  # Если общая длина превышает 30 символов,
                    text += " " * 2  # добавляем 2 дополнительных пробела.

                text += str(v)  # Добавляем значение к тексту.
                text += "\n"  # Добавляем перевод строки между ключами и значениями.
            text += "\n"  # Добавляем пустую строку после каждого объекта.
            text += "******************************"  # Добавляем разделительную строку.
            text += "\n"

        text += ""  # Пустая строка (это выглядит как ошибка, потому что она ничего не делает).
        index = 0  # Начальный индекс для разделения текста на части.
        size = 4000  # Максимальная длина каждой части сообщения.
        while len(text) > 0:  # Пока есть текст для обработки:
            part = text[
                index : index + size
            ]  # Выбираем часть текста длиной не более 4000 символов.
            index = part.rfind(
                "\n"
            )  # Находим последний символ перевода строки в части.
            if index == -1:  # Если символ перевода строки не найден,
                index = len(text)  # используем всю часть текста.
            part = text[
                0:index
            ]  # Выбираем часть текста до найденного символа перевода строки.
            messages.append(
                "```\n" + part + "\n```"
            )  # Добавляем часть текста в список сообщений,
            text = text[index:].strip()  # и удаляем ее из исходного текста.

        logger.debug("Finished formatting messages")
    else:
        logger.debug("Input object is empty")

    return messages  # Возвращаем список отформатированных сообщений.


def format_message_list5(obj):
    text = ""  # Создаем пустую строку для хранения текста сообщений.
    messages = []  # Создаем пустой список для хранения отформатированных сообщений.

    if len(obj) > 0:  # Проверяем, есть ли объекты в списке.
        logger.debug("Processing non-empty object")
        for i in obj:  # Проходим по каждому объекту в списке.
            for k, v in i.items():  # Проходим по каждой паре ключ-значение в объекте.
                key = str(k)  # Преобразуем ключ в строку.
                val = str(v)  # Преобразуем значение в строку.
                total_len = len(key) + len(
                    val
                )  # Вычисляем общую длину ключа и значения.
                pad = (
                    30 - total_len % 30
                )  # Вычисляем количество пробелов, чтобы выровнять текст.

                text += key  # Добавляем ключ к тексту.

                if pad > 0:  # Если нужно добавить пробелы для выравнивания,
                    text += " " * pad  # добавляем их.

                if total_len > 30:  # Если общая длина превышает 30 символов,
                    text += " " * 2  # добавляем 2 дополнительных пробела.

                text += str(v)  # Добавляем значение к тексту.
                text += "\n"  # Добавляем перевод строки между ключами и значениями.
            text += "\n"  # Добавляем пустую строку после каждого объекта.
            text += "******************************"  # Добавляем разделительную строку.
            text += "\n"

            text += ""
            index = 0  # Начальный индекс для разделения текста на части.
            size = 4000  # Максимальная длина каждой части сообщения.
            # while len(text) > 0:  # Пока есть текст для обработки:
            part = text[
                index : index + size
            ]  # Выбираем часть текста длиной не более 4000 символов.
            index = part.rfind(
                "\n"
            )  # Находим последний символ перевода строки в части.
            if index == -1:  # Если символ перевода строки не найден,
                index = len(text)  # используем всю часть текста.
            part = text[
                0:index
            ]  # Выбираем часть текста до найденного символа перевода строки.
            messages.append(
                "```\n" + part + "\n```"
            )  # Добавляем часть текста в список сообщений,
            text = text[index:].strip()  # и удаляем ее из исходного текста.
        logger.debug("Finished formatting messages")
    else:
        logger.debug("Input object is empty")

    return messages  # Возвращаем список отформатированных сообщений.
